# create seqtest data
# the returned data set should have all sequences and an indicator showing if subject completed all sequences

create_seqtest <- function(ex){
  
  med <- ex %>% mutate(ptno = as.numeric(CLIENTID),
                       EX_TRT_C = substr(EX_TRT_C, 4, 4),   # get the treatment lable
                       pern = as.numeric(gsub("A|B|C|D|E|F", "", PERIOD)) # remove A or B or C, ect.  equivalent to compress() in SAS
                      )
  
  medseq <- med %>% arrange(ptno, pern, EX_TRT_C) %>% 
    group_by(ptno, pern, EX_TRT_C) %>% filter(row_number()==1)
  
  
  # total number of period
  totper <- length(unique(med$pern))
  tottrt <- length(unique(med$EX_TRT_C))
  
  seqtest <- dcast(medseq, ptno ~ pern, value.var="EX_TRT_C")
  ## add a prefix to the transformed variable
  id0 <- which(!(names(seqtest)%in% c("ptno", "pern")))
  names(seqtest)[id0] <- paste("dosed_", names(seqtest)[id0], sep = "") 
  
  
  # replace "NA" with "_"
  char_replace <- as.list(rep("_", length(id0)))
  names(char_replace) <- names(seqtest)[id0]
  seqtest <- replace_na(seqtest, replace=char_replace)
  
  # combine the treatments to make a sequence
  seqtest <- unite_(seqtest, "seq", names(seqtest)[id0], sep ="", remove = F)
  
  # set trtflg=* if trt is missing in a period;
  seqtest <- seqtest %>% mutate(trtflg = ifelse(grepl("_", seq), "*", ""))
  
  seqtest$rseq <- seqtest$seq
  
  return(seqtest)
  
}

# create chkseq data
# the returned data set should have all sequences and an indicator showing if subject checked in at least one sequence

create_chkseq <- function(dm, cr){
  
  # add all ptno from the DM dataset to add any ptno that did not get dosed
  dem <- dm %>% mutate(ptno = as.numeric(CLIENTID)) %>% select(ptno, SCRID, CLIENTID)
  
  # additional code to determine if a subject checked in in each period
  chk <- cr %>% mutate(ptno = as.numeric(CLIENTID), chk = "Y",
                       pern = as.numeric(gsub("A|B|C|D|E|F", "", PERIOD))) %>%
    select(ptno, CR_DAT, pern, chk) %>%
    arrange(ptno, pern, chk) %>% 
    group_by(ptno, pern, chk) %>%
    filter(row_number()==1)
  
  # Creating the chkseq variable which is a concatentation of the Y or N    in
  # period 1, the check in for period 2,.....                                 
  
  chkseq <- dcast(chk, ptno + CR_DAT ~ pern, value.var = "chk")
  # add a prefix to the variables generated by pern.
  id1 <- which(!(names(chkseq)%in% c("ptno", "CR_DAT")))
  names(chkseq)[id1] <- paste("chk_in_", names(chkseq)[id1], sep = "") 
  # this dcast is not exactly what proc transpose does, need one more step
  if (length(id1)>1){
    base <- chkseq %>% select(ptno, CR_DAT, chk_in_1) %>% filter(!is.na(chk_in_1))
    for (i in 2:length(id1)){
      
      per_i <- chkseq %>% select(ptno, matches(paste("chk_in_", i, sep = ""))) 
      row_keep <- !is.na(per_i[, 2])
      per_i <- per_i[row_keep, ]
      
      base <- left_join(base %>% arrange(ptno), per_i %>% arrange(ptno),
                        by = c("ptno"))
    }
    chkseq <- base
  }

  
  ## decide if there is subject who never checked in (will be flagged with *) 
  col_ids <- starts_with("chk_in_", vars = names(chkseq))
  ch2 <- as.list(rep("_", length(col_ids)))
  names(ch2) <- names(chkseq)[col_ids]
  chk_in_0 <- replace_na(chkseq, replace = ch2)
  chk_in_0 <- unite_(chk_in_0,"CHECKED", names(chk_in_0)[col_ids], sep= "", remove=F)
  id_checked <- grepl("Y|YES", toupper(chk_in_0$CHECKED))
  chk_in_0$chkflg <-  ifelse(id_checked, "", "*")
  
  return(chk_in_0)
  
  
}


create_dis <- function(ds){
  med <- ex %>% mutate(ptno = as.numeric(CLIENTID),
                       EX_TRT_C = substr(EX_TRT_C, 4, 4),   # get the treatment lable
                       pern = as.numeric(gsub("A|B|C|D|E|F", "", PERIOD)) # remove A or B or C, ect.  equivalent to compress() in SAS
                       )
  totper <- length(unique(med$pern))
  
  dis <- ds %>% mutate(ptno = as.numeric(CLIENTID))
  ds_ans_exist <- any(names(dis) %in% "DS_ANS")
  if(ds_ans_exist){
    dis$comp <- ifelse(dis$DS_ANS %in% c("YES", "Y"), "Y", "")
  } else{
    dis$comp <- ""
  }
  names(dis)[ncol(dis)] <- paste("comp_", totper, sep = "")
  
  dis <- dis %>% select(ptno, starts_with("comp_"))  # the SAS code has DS_ANS included
  return(dis)  
}


#' new_create_included.
#'
#' @title do what new_create_included does.
#' @param ex  the dataset ex read from sas
#' @param dm  the dataset dm read from sas
#' @param cr  the dataset cr read from sas
#' @param ds  the dataset ds read from sas
#' @return the included data set
#' @export
#'
#'

new_create_included <- function(ex, dm, cr, ds){
  
  dem <- dm %>% mutate(ptno = as.numeric(CLIENTID)) %>% select(ptno, SCRID, CLIENTID)
  seqtest <- create_seqtest(ex)
  chk_in <- create_chkseq(dm, cr)
  dis <- create_dis(ds)
  
  seqtest1 <- full_join(seqtest %>% arrange(ptno), 
                        full_join(dem %>% arrange(ptno),
                            full_join(chk_in %>% arrange(ptno), 
                                      dis %>% arrange(ptno)))) %>%
              mutate(flag = "")
  id3 <- seqtest1$trtflg != "" | seqtest1$chkflg != ""  # the SAS code has DS_ANS included
  seqtest1$flag[id3] <- "*"
  
  seqtest2 <- seqtest1 %>% select(-trtflg, -chkflg) %>% 
              mutate(compprot = ifelse(flag != "",  "Y", "N"), 
                     safeanal = "Y",
                     pkanal = ifelse(flag != "", "Y", "N"))
  
  names(seqtest2) <- toupper(names(seqtest2))
  return(seqtest2)
}


