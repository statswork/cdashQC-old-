################################################################################################
#                                  Lab -- out of range values
#
################################################################################################



# create the range variable, the input data should have at least the following 
# variables included: LB_ORLO, LB_ORHI, LB_TESTC, sex, LB_STNRC
create_range <- function(data){
  
  all_exist <- sum (names(data)  %in% c("LB_ORLO", "LB_ORHI", "LB_TESTC", "sex", "LB_STNRC")) == 5
  if(!all_exist) stop("at least one of the following \n LB_ORLO, LB_ORHI, LB_TESTC, sex, LB_STNRC\n does not exist or not named correctly, check your data") 
  
  low <- trimws(data$LB_ORLO)
  high <- trimws(data$LB_ORHI)
  testc <- trimws(data$LB_TESTC)
  sex <- trimws(data$sex)
  stnrc <- trimws(data$LB_STNRC)
  
  age <- rep("", length(low))
  range0 <- range1 <- rep("", length(low))
  
  id1 <-  testc  =="ALP" &  low == "48"  &  high == "131"
  id2 <-  testc  =="ALP" &  low  == "45" &  high  == "120"
  id3 <-  testc  =="ALP" &  low  == "38" &  high  == "104"
  id4 <-  testc  =="ALP" &  low  == "37" &  high  == "115"
 
  age[id1 | id3] <- "0-25"; age[id2 | id4] <- "26-99"
  
  id5 <- low != ""
  id6 <- high != ""
  id7 <- grepl("NEG", stnrc) | grepl("NOT", stnrc) | grepl("TRAC", stnrc) | grepl("POS", stnrc) |
         grepl("0-", stnrc) | grepl("NON", stnrc) | grepl("CLEAR", stnrc) | grepl("YELLOW", stnrc)
  
  range0[id5] <- paste(low[id5], high[id5], sep = "-")
  range0[!id5 & id6] <- high[!id5 & id6]
  range0[!id5 & !id6 & id7] <- stnrc[!id5 & !id6 & id7]
  range0[!id5 & !id6 & !id7 & stnrc != ""] <- paste("<", stnrc[!id5 & !id6 & !id7 & stnrc != ""])
  
  id8 <- sex == ""
  id9 <- age == ""
 
  range1[!id8 & id9 ] <- paste(substr(sex[!id8 & id9 ], 1, 1), ":", range0[!id8 & id9 ], sep = "")
  range1[!id8 & !id9] <- paste(age[!id8 & !id9], "/", substr(sex[!id8 & !id9], 1, 1), ":", range0[!id8 & !id9], sep = "")
  range1[id8  & id9] <- range0[id8 & id9]
  range1[id8 & !id9] <- paste(age[id8 & !id9], ":", range0[id8 & !id9])
  
  data$age <- age
  data$range <- range1
  return(data)
}


# create the laborig data, changing the format (or values) of some variables 
create_laborig <- function(lb_cq){
  
  laborig <- lb_cq %>% mutate(ptno = as.numeric(CLIENTID), 
                              sex = LB_SEX_C, 
                              LB_CAT = replace(LB_CAT, !(trimws(LB_CAT) %in% c('CHEM','HEME','UA','UDS','COAG','VIROL')), "OTH"), 
                              LB_ORRES = replace(LB_ORRES,trimws(toupper(LB_CMTST)) == "CLOTTED UNABLE TO ANALYZE", "CUTA"), 
                              LB_ORRES = replace(LB_ORRES,trimws(toupper(LB_CMTST)) == "TOO NUMEROUS TO COUNT", "TNTC"))
  
  id1 <- trimws(toupper(laborig$LB_TESTC)) == "CK-MB"
  id2 <- trimws(toupper(laborig$LB_TESTC)) == "A/G"
  id3 <- trimws(toupper(laborig$LB_TESTC)) == "B/C"
  
  
  laborig <- laborig %>% mutate(LB_TESTC = replace(LB_TESTC, id1, "CKMBB"), 
                                LB_TESTC = replace(LB_TESTC, id2, "AG"), 
                                LB_TESTC = replace(LB_TESTC, id3, "BC"), 
                                LB_ORREU = replace(LB_ORREU, id2, "RATIO"),
                                LB_ORREU = replace(LB_ORREU, id3, "RATIO")) 
                      
   return(laborig)
}



# #' Find the normal range of each test code
# #' 
# #' @title Find normal range
# #' @param laborig  the dataset generated by \code{create_laborig}
# #' @return a data frame containing test codes and their corresponding normal range


normal_range <- function(laborig){

  ranges <- laborig %>% select(LB_CAT, LB_TESTC, LB_ORLO, LB_ORHI, sex, LB_STNRC) %>%
            arrange(LB_CAT, LB_TESTC, LB_ORLO, LB_ORHI, sex) %>%
            distinct()
  
  male <- ranges %>% filter( trimws(toupper(sex)) %in% c("MALE", "M")) %>%
                  arrange(LB_CAT, LB_TESTC, LB_ORLO, LB_ORHI, LB_STNRC)
  female <- ranges %>% filter( trimws(toupper(sex)) %in% c("FEMALE", "F")) %>%
                  arrange(LB_CAT, LB_TESTC, LB_ORLO, LB_ORHI, LB_STNRC)
  
  newrg <- full_join(male, female, by = c("LB_CAT", "LB_TESTC", "LB_ORLO", "LB_ORHI", "LB_STNRC"))
       
  # create a sex variable, if sex is not empty, then this testcode is specific for this gender.
  newrg$sex <- ""
  id1 <- is.na(newrg$sex.y); id2 <- is.na(newrg$sex.x)
  newrg$sex[!id1 & id2] <- newrg$sex.y[!id1 & id2]; newrg$sex[id1 & !id2] <- newrg$sex.x[id1 & !id2]
  newrg <- newrg %>% select(-sex.x, -sex.y)
  
  # creating the range variable seems to be a complicated data step, so I write a function to do it.
  tworg <- create_range(newrg)  # creates the range variable 

  tworg <- tworg %>% select(LB_CAT, LB_TESTC, sex, range ) %>% 
                     arrange(LB_CAT, LB_TESTC, sex, range) %>% 
                     mutate(sex = replace(sex, sex == "", "A"))
  
  temp1 <- tworg %>% group_by(LB_CAT, LB_TESTC, sex) %>% 
    filter(row_number()==1)
  
  temp2 <- tworg %>% group_by(LB_CAT, LB_TESTC, sex) %>% 
                filter(row_number()>1)
  

  
  data1 <- left_join(temp1, temp2, by = c("LB_CAT", "LB_TESTC", "sex")) %>%
            mutate(range.y = replace(range.y, is.na(range.y), ""))
  

  final_range <- data1 %>% mutate(range = paste(range.x, range.y, sep =" "))  %>%
                          mutate(range = replace(range, range.y=="", range.x), 
                                 lgthrge = nchar(range)) %>%  # define the length of each range
                          select(-range.x, -range.y)     %>%  # don't need these two variable 
                          arrange(LB_CAT, LB_TESTC, range, lgthrge)    
  
  lb_orlog <- final_range %>% group_by(LB_CAT, LB_TESTC, range, lgthrge) %>%
                          filter(row_number() == n())         # select if last.obs
  return(lb_orlog)

}



# #' Find the out-of-range values
# #' 
# #' @title Find OOR
# #' @param lb_cq  the SAS dataset.
# #' @param transpose   Should the data be transposed? FALSE by default (This corresponds to just filtering lb_cq by OOR conditions).
# #' @return a data frame containing OOR

oor_value <- function(lb_cq, transpose = F){
  
  oor  <- create_laborig(lb_cq) %>%                   #  all cases of out of range values
                   filter(trimws(LB_NRIND) != "" |
                          trimws(LB_CSGFG) != "" |
                          trimws(LB_PISIG) != "" |
                          trimws(LB_UNSCH) != "" |
                          trimws(toupper(PERIOD)) == "EARLY TERMINATION" |
                          trimws(toupper(PERIOD)) == "UNSCHEDULED")

  if (transpose) {
    id1 <-  trimws(toupper(oor$PERIOD)) == "EARLY TERMINATION" | trimws(toupper(oor$PERIOD)) == "UNSCHEDULED"
    oor$period_code <- oor$PERIOD
    oor$period_code[!id1] = ""
    
    oor <- oor %>% mutate(LB_ORRES = paste(     # compbine all the abnormal signals
                          trimws(LB_ORRES), " ",
                          trimws(LB_NRIND), "",
                          trimws(LB_CSGFG), "",
                          trimws(LB_PISIG), "",
                          trimws(LB_UNSCH), " ", 
                          trimws(period_code), sep = ""),
                          LB_TESTC = paste(trimws(LB_CAT), trimws(LB_TESTC), sep = "_")) %>%
                  select(ptno, sex, LB_DAT,LB_TIM, LB_TESTC, LB_ORRES, PERIOD, DAY, HOUR) %>%
                  dcast(ptno + sex + PERIOD + DAY + HOUR + LB_DAT + LB_TIM ~ LB_TESTC, value.var = "LB_ORRES")     
    
  }
                                
  return(oor)
  
}


##  read the full name of the codes
the_code <- function(lb_cq){
  # should have this data loaded by the time you load the package!

  lab_cat <- lb_cq %>% select(LB_CAT, LB_TESTC) %>% 
                  arrange(LB_CAT, LB_TESTC) %>% distinct()
  
  codes <- right_join(codes %>% arrange(LB_TESTC), 
                      lab_cat %>% arrange(LB_TESTC), by = "LB_TESTC") 
  return(codes)
}



##  I don't know what this function is doing

oor_range <- function(lb_cq){
   
  laborig  <- oor_value(lb_cq)  # all cases of out of range values

  new0 <- laborig %>% select(LB_CAT, LB_TESTC, LB_ORRES, LB_NRIND, LB_CSGFG, LB_PISIG)  %>%
                      mutate(lgth = nchar(LB_ORRES))
  
  # This data set contains the length that each test code requires (by its actual value)
  new1 <- new0 %>% arrange(LB_CAT, LB_TESTC, lgth) %>% 
                  distinct() %>%  # select distinct values
                  group_by(LB_CAT, LB_TESTC, lgth) %>%
                  filter(row_number() == n())  %>%  # keep rows having max(lgth) in each group
                  select(-LB_ORRES)                 # drop LB_ORRES
                
    
  lb_orlog <- normal_range(laborig)                 # get the normal range values 
  
  new <- left_join(new1 %>% arrange(LB_CAT, LB_TESTC), 
                    lb_orlog %>% arrange(LB_CAT, LB_TESTC), 
                    by = c("LB_CAT", "LB_TESTC") )
  new$lgth <- ifelse(new$lgthrge > new$lgth, new$lgthrge, new$lgth )

  #  pulling in the dataset from labcodes.mac to determine the title names 
  #  and the column width for this test in labcodes.mac.  If this width is 
  #  not as long as the longest lb_orres or range, the width is replaced with the   
  #  longest lb_orres for your lab dataset     
     
  # codes <- read.csv("Y:/development/users/Zhuob01/R-template/data/CODES.csv",stringsAsFactors=F) %>% 
  #             filter(lb_testc != "")
  # names(codes) <- toupper(names(codes))
  # codes$LB_TESTC <- as.character(codes$LB_TESTC)
  
  test <- right_join(codes %>% arrange(LB_TESTC), new, by = "LB_TESTC")
  test$COLWIDE <- ifelse(test$lgth > test$COLWIDE |  is.na(test$COLWIDE), test$lgth, test$COLWIDE)
  
  codes2 <- test %>% mutate(colwd = COLWIDE + 4) %>% 
                  group_by(LB_CAT, TESTNUM, TTL) 
  
  result <- list(laborig= laborig, codes = codes2)
  
  return(result)
}



# lb_orreu <- toupper(trimws(laborig$LB_ORREU))
# id1 <-  lb_orreu == "X 10^9/L" | lb_orreu == "X10^9/L"
# id2 <-  lb_orreu == "X 10^12/L" | lb_orreu == "X10^12/L"
# id3 <- lb_orreu != ""
# 
# one0 <- laborig %>% mutate( LB_ORREU = replace(LB_ORREU, id1, "thou/uL"), 
#                             LB_ORREU = replace(LB_ORREU, id2, "mil/uL"))
# one0$LB_ORREU[id3] <-  paste("(", trimws(one0$LB_ORREU[id3]), ")", sep = "")  
#
# id5 <-  trimws(toupper(PERIOD)) != "EARLY TERMINATION" & trimws(toupper(PERIOD)) != "UNSCHEDULED"
#
# one1 <- one0 %>% select(LB_TESTC, LB_ORREU, LB_TEST)  %>%
#                  arrange(LB_TESTC, LB_ORREU, LB_TEST) %>%
#                  distinct()
# 
# one <- left_join(one1, codes %>% arrange(LB_TESTC), by = "LB_TESTC") %>% 
#         mutate(COLWIDE = replace(COLWIDE, is.na(COLWIDE), 8) ) 
# id4 <- which(is.na(one$TTL))
# one$TTL[id4] <- one$LB_TEST[id4]
# one_update <- one %>% arrange(LB_TESTC, LB_TEST, LB_ORREU, TESTNUM, TTL, LB_CAT, COLWIDE)



# #' Export the oor values
# #' 
# #' @title Export the oor values by LB_CAT
# #' @param lb_cq  the dataset lb_cq read from sas
# #' @param ex  the dataset ex, used to get treatment information.
# #' @return a data frame containing test codes and their corresponding normal range


lab_rept <- function(lb_cq, ex, cat = "UA"){
  
  oor_all <- oor_value(lb_cq, transpose = T) # all cases of out of range values
  
  # get the treatment information
  ex_trt <- ex %>% mutate(ptno = as.numeric(CLIENTID))  %>% select(ptno, EX_TRT_C) 
  
  oor_value <- right_join(ex_trt %>% arrange(ptno, EX_TRT_C), 
                          oor_all %>% arrange(ptno), by = "ptno")
  
  # decide whether this CAT has oor listed in data 
    var_names <- names(oor_value)
    cat_exist <- grepl(paste(cat, "_", sep = ""), var_names)
    
    if (any(cat_exist)){
      oor <- oor_value %>% select(ptno, sex, EX_TRT_C, PERIOD, DAY, HOUR, LB_DAT, LB_TIM, starts_with(paste(cat, "_", sep = "")))
      
      return(oor)
    }
    
    else { message(paste("Whoops! ", cat, " does not have out-of-range values OR \nvariable LB_CAT does not contain the value '", cat, "'", sep = ""))}
    
}



# #' print out the OOR values
# #' 
# #' @title print oor values by LB_CAT
# #' @param lb_cq  the dataset lb_cq read from sas
# #' @param ex  the dataset ex, used to get treatment information.
# #' @param cat which LB_CAT code will be used ("UA" for example)
# #' @param var_per_block  how many variables to be shown in each block
# #' @param digit_keep  the digit kept in the output. see \code{kable()} for more details
# #' @export


customized_lab_rept <- function(lb_cq, ex, cat= "UA", var_per_block=5, digit_keep = 2){
  
  oor <- lab_rept(lb_cq, ex, cat)
  

  if (!is.null(oor)){
    # first, separate the data into two, one for fixed columns (those columns will be the same for all output)
    part1 <- oor %>% select(-starts_with( paste(cat, "_", sep = "")))
    part2 <- oor %>% select(starts_with( paste(cat, "_", sep = "")))
    the_rest_name <-  names(part1)
    cat_name <-  names(part2)
    
    # need full name of the codes 
    codes <- the_code(lb_cq) %>% 
            mutate(var_name = paste(LB_CAT, "_", LB_TESTC, sep=""),
                   TTL = gsub("~", " ", TTL))      # change "~" to " " in TTL, this will make the column names wrap
    # and also the normal ranges         
    range0 <- create_laborig(lb_cq) %>% normal_range() 
    ranges <- range0  %>% dcast(LB_CAT + LB_TESTC ~sex, value.var= "range")
    ids <- is.na(ranges$A)
    ranges$A[ids] <- paste(ranges$FEMALE[ids], ranges$MALE[ids], sep = " ")
    ranges <- ranges %>% mutate(range = A) %>% select(LB_CAT, LB_TESTC, range)
    
    # the full name will come with its normal range
    codes <- left_join(codes %>% arrange(LB_CAT, LB_TESTC), 
                       ranges %>% arrange(LB_CAT, LB_TESTC), 
                        by = c("LB_CAT", "LB_TESTC")) %>%
              mutate(TTL = paste(TTL, range, sep = " "))

    
    ## devivde the variables into multiple blocks and print them one by one.
    
    block <- ceiling(length(cat_name)/var_per_block)  # how many variables per block
    for ( k in 1:block){
      if(k == block){                        # if this is the last block
        from1 <- (k-1)*var_per_block + 1
        to1 <- length(cat_name)
        # c(from1, to1)
        
        # get the corresponding code
        test_code <- as.character(cat_name[from1:to1])
        testcode <- data.frame(var_name = test_code, stringsAsFactors=F) 
        
        # match the code with its full name
        full_name <- left_join(testcode %>% arrange(var_name), 
                               codes %>% arrange(var_name), by = "var_name") %>%
                      select(var_name, TTL) %>% distinct()
        
        col_to_show <- which(cat_name %in% test_code)
    
        part2_1 <- part2[, col_to_show]          # keep those names in this output
        emt <- keep_non_empty(part2_1)           # get the index of empty columns and empty rows
        
        part2_keep <- part2_1[, emt$keep_cols]   # remove empty columns
       
        id1 <- is.na(part2_keep)                 # replace "NA" with ""
        part2_keep[id1] <- ""
        
        oor1 <- cbind(part1, part2_keep)         # remove empty rows
        oor1 <- oor1[emt$keep_rows, ]
        
        # now the column names with full test name 
        col_name <- c(as.character(the_rest_name), as.character(full_name$TTL[emt$keep_cols]))
        rownames(oor1) <- NULL
        # print out
        print(kable(oor1, digits =digit_keep, table.attr='class="flat-table"',
                    col.names = col_name, caption = paste(cat, ":block ", k, " of ", block, sep = "")))
      }
      
      else {                 # if this is not the last block
        from1 <- (k-1)*var_per_block + 1
        to1 <-  k*var_per_block;
       
        # get the corresponding code
        test_code <- as.character(cat_name[from1:to1])
        testcode <- data.frame(var_name = test_code, stringsAsFactors=F) 
        
        # try to match the code with its full name
        full_name <- left_join(testcode %>% arrange(var_name), 
                               codes %>% arrange(var_name), by = "var_name") %>%
                     select(var_name, TTL) %>% distinct()
        
        col_to_show <- which(cat_name %in% test_code)
        
        part2_1 <- part2[, col_to_show]          # keep those names in this output
        emt <- keep_non_empty(part2_1)           # get the index of empty columns and empty rows
        
        part2_keep <- part2_1[, emt$keep_cols]   # remove empty columns
        
        id1 <- is.na(part2_keep)                 # replace "NA" with ""
        part2_keep[id1] <- ""
        
        oor1 <- cbind(part1, part2_keep)         # remove empty rows
        oor1 <- oor1[emt$keep_rows, ]
        rownames(oor1) <- NULL
        
        # now the column names with full test name 
        col_name <- c(as.character(the_rest_name), as.character(full_name$TTL[emt$keep_cols]))
          
        # print out 
        print(kable(oor1, digits =digit_keep, table.attr='class="flat-table"',col.names = col_name, 
                    caption = paste(cat, ":block ", k, " of ", block, sep = "")))
        
        }
      
      }
  
    
  }
  
}





#' print out the OOR values for all LB_CAT automatically. This function is built on top of customized_lab_rept()
#' 
#' @title print OOR values for all LB_CAT
#' @param lb_cq  the dataset lb_cq read from sas
#' @param ex  the dataset ex, used to get treatment information.
#' @param var_per_block  how many variables to be shown in each block
#' @param digit_keep  the digit kept in the output. see \code{\link[knitr]{kable()}} for more details
#' @export


all_lab_rept <- function(lb_cq, ex, var_per_block = 5, digit_keep = 2){
  
  laborig <- create_laborig(lb_cq)
  cat_all <- unique(laborig$LB_CAT)
  
  for (i in 1: length(cat_all)){
    customized_lab_rept(lb_cq, ex, cat= cat_all[i], var_per_block=var_per_block, digit_keep = digit_keep)
      
  }
  
}

